Funcoes
    fork   #include <unistd.h> 
        Como funciona o fork():

        Quando o processo pai chama fork(), o sistema cria uma cópia do processo pai e o novo processo é chamado de processo filho.
        O processo filho herda quase todo o ambiente do processo pai, como variáveis de ambiente, descritores de arquivos abertos, etc.
        Tanto o processo pai quanto o processo filho continuam a execução a partir do ponto onde o fork() foi chamado.

        Retorno de fork():

        No processo pai, fork() retorna o PID do processo filho.
        No processo filho, fork() retorna 0.
        Se ocorrer um erro na criação do processo filho, fork() retorna -1.

        Exemplo de uso:
        int main() {
            pid_t pid = fork();

            if (pid < 0) {
                // Se fork() falhou
                printf("Erro ao criar processo filho\n");
            } else if (pid == 0) {
                // Código executado pelo processo filho
                printf("Processo filho: Meu PID é %d\n", getpid());
            } else {
                // Código executado pelo processo pai
                printf("Processo pai: Criei um filho com PID %d\n", pid);
            }
            return 0;
        }
        
        pid_t é um tipo de dado definido em C (em sistemas Unix e Unix-like) que é usado para armazenar identificadores de processos, conhecidos como PIDs (Process IDs). Ele é um tipo de signed int, mas o tipo exato pode variar dependendo da implementação do sistema operacional.
    

    wait  #include <sys/wait.h>

        pid_t wait(int *status);

        A funcao wait() em C e usada para fazer com que um processo pai aguarde a finalizacao de um ou mais processos filhos (Se houve algum processo filho que nao tenha acabado a sua execussao ele fica a aguardar).

        Parametros:
            status: E um ponteiro para um inteiro onde o status de termino do processo filho sera armazenado. Se nao estivermos interessados no status de saida podemos passar NULL. O statuss pode ser analizado com macros como: WIFEXITED() :    WEXITSTATUS()   WIFSIGNALED() entre outras -------------------------
            WIFEXITED(status): Retorna verdadeiro se o processo filho terminou normalmente (ou seja, usou exit() ou retornou da main()).
            WEXITSTATUS(status): Retorna o código de saída do processo filho se ele terminou normalmente (o valor passado para exit()).
            WIFSIGNALED(status): Retorna verdadeiro se o processo filho foi encerrado por um sinal.
            WTERMSIG(status): Retorna o número do sinal que causou a finalização do processo filho.
            WIFSTOPPED(status): Retorna verdadeiro se o processo filho foi parado por um sinal (mas não terminado).


        Valores de retorno:
            Retorna o PID do processolho filho que terminou --------------------
            Retorna -1 em caso de erro

    waitpid()

        pid_t waitpid(pid_t pid, int *status, int options);

        cid: Pode especificar o PID de um processo específico para esperar, ou outras opções como -1 (esperar por qualquer filho).
        options: Pode incluir opções como WNOHANG (não espera, retorna imediatamente se nenhum filho tiver terminado) e WUNTRACED (retorna se um processo filho tiver sido parado, mas não terminado).

        As principais opções que você pode usar:

            WNOHANG
                Como já discutimos, essa opção faz com que waitpid() não bloqueie se o filho ainda não tiver terminado. Em vez disso, ele retorna imediatamente e você pode continuar executando outras tarefas.
            WUNTRACED
                Faz com que waitpid() retorne também se um filho for parado (não apenas terminado) por um sinal (como um Ctrl + Z no terminal). Normalmente, waitpid() só retornaria se o processo filho terminasse de fato, mas com WUNTRACED, você é notificado mesmo que o filho apenas suspenda (não termine).
                Útil para detectar quando um filho é temporariamente interrompido e está apenas em estado "parado".
            WCONTINUED
                Retorna se um filho que estava parado (suspendido) é continuado (retoma a execução) após receber o sinal SIGCONT.
                Essa opção permite que você monitore quando um processo filho que foi interrompido (exemplo: Ctrl + Z) volta a rodar depois de ser "despausado".
            WEXITED
                Com waitid() (outra função relacionada), essa opção espera apenas processos que terminaram normalmente. É como WIFEXITED() no waitpid(), mas você passa como opção.
            WSTOPPED
                Similar a WUNTRACED, mas usado com waitid(). Faz com que waitid() retorne informações sobre processos que foram parados por sinais como SIGSTOP.
            WNOWAIT
                Se usado com waitid(), não remove o status de término do processo filho quando ele termina, ou seja, deixa o status "pendente". Isso permite que você consulte o status de término várias vezes sem "limpar" a informação.
            __WALL
                Retorna o status de todos os processos filhos, mesmo que estejam em grupos de processos diferentes. Normalmente, waitpid() só retorna informações sobre filhos do mesmo grupo.
                Não é muito usado, mas pode ser útil em contextos específicos.
            __WCLONE
                Monitora apenas processos que não compartilham o mesmo grupo de processos. Essa é uma opção avançada para contextos que envolvem threads e processos criados com clone().

        Como usar essas opções?
        Essas opções são passadas como um argumento adicional na chamada à função waitpid(). Elas podem ser combinadas usando o operador bitwise OR (|) para que você use mais de uma opção ao mesmo tempo. Por exemplo:

        waitpid(pid, &status, WNOHANG | WUNTRACED);


    readline() e add_history()  #include <readline/readline.h>
                                #include <readline/history.h>
                            
        A função readline() é usada para ler uma linha de texto do terminal de forma interativa, permitindo ao usuário editar a linha, mover o cursor, e navegar no histórico de comandos.

        Sintaxe:
            char *readline(const char *prompt);
            Mostra um prompt (texto que aparece antes da linha de entrada) e aguarda o usuário digitar algo.
            Retorna um ponteiro para a string digitada ou NULL se o usuário pressionar Ctrl+D (EOF).

        Principais recursos:
            Edição de linha: Permite corrigir a entrada antes de pressionar "Enter".
            Histórico de comandos: Permite armazenar e recuperar entradas anteriores usando funções como add_history().
            Autocompletar: Pode ser configurada para sugerir ou completar automaticamente palavras.

        Compilação: Ao compilar, é necessário linkar a biblioteca com -lreadline.

        Para adicionar um input ao historico usamos a add_history e podemos navegar pelo historico atraves das setas
        
        Sintaxe: void add_history(const char *line);
            line seria a string a ser gravada no historico

    
    rl_clear_history()
        Sintaxe:
                void rl_clear_history(void);

                Parâmetros: A função não recebe parâmetros.
                Retorno: A função não retorna nada.

                Descricao:
                Limpa todos os itens do histórico que foram adicionados por chamadas a add_history().
                Se o histórico for salvo em um arquivo usando write_history(), isso não afetará o histórico já salvo no arquivo, apenas o histórico em memória será limpo.

    
    Estrutura struct termios #include <termios.h>
        A estrutura termios contém as configurações do terminal. Cada campo dessa estrutura controla uma parte do comportamento do terminal, e você pode manipulá-los para modificar como o terminal lida com entradas e saídas.
        struct termios termios_p;
    
        Estrutura termios:
            c_lflag (Local modes): Controla as opções de modo local, como se o terminal deve ecoar os caracteres digitados e como os sinais são tratados (por exemplo, Ctrl+C).
            c_iflag (Input modes): Controla as opções de modo de entrada, como se o terminal deve processar caracteres de controle.
            c_oflag (Output modes): Controla as opções de modo de saída, como se o terminal deve processar os caracteres de controle de nova linha.
            c_cflag (Control modes): Controla as opções de modo de controle, como a velocidade da comunicação serial.
            c_cc[] (Control characters): Um array de caracteres de controle, como o caractere que representa a tecla de "fim de arquivo" (EOF) ou "apagar" (DEL).

        c_lflag (Local Mode Flags)
            O campo c_lflag controla o modo local do terminal. Aqui estamos manipulando a flag ECHOCTL:
                ECHOCTL: Se essa flag estiver definida, os caracteres de controle (como Ctrl+C, Ctrl+D) são exibidos no terminal na forma de ^C, ^D, etc. 
                Quando removemos essa flag (usando &= ~ECHOCTL  => BITWISE HELLO XD), esses caracteres de controle não são mais exibidos no terminal.

    Funções tcgetattr e tcsetattr   <termios.h>

        tcsetattr(int fd, int optional_actions, const struct termios *termios_p)
            Esta função lê as configurações atuais do terminal e armazena-as na estrutura termios apontada por termios_p.
            Essa função retorna 0 em caso de sucesso e -1 em caso de falha.

            Parametros:
                fd: O descritor de arquivo que representa o terminal. Para manipular a entrada padrão (teclado), usamos STDIN_FILENO (definido como 0), que é o descritor para o terminal de entrada.
                termios_p: Um ponteiro para uma estrutura termios, onde as configurações atuais do terminal serão armazenadas.

        tcsetattr(int fd, int optional_actions, const struct termios *termios_p)

            Esta função aplica as configurações do terminal armazenadas na estrutura termios apontada por termios_p para o terminal indicado pelo descritor de arquivo fd.
            Essa função também retorna 0 em caso de sucesso e -1 em caso de falha.

                Parametros:
                    fd: O descritor de arquivo do terminal (como STDIN_FILENO).
                    optional_actions: Determina quando as mudanças nas configurações devem ser aplicadas. Algumas opções incluem:
                        TCSANOW: Aplica as mudanças imediatamente.
                        TCSADRAIN: Aplica as mudanças após esvaziar os buffers de saída.
                        TCSAFLUSH: Aplica as mudanças após esvaziar tanto os buffers de entrada quanto os de saída.
                    termios_p: Ponteiro para a estrutura termios que contém as configurações que serão aplicadas.
        struct termios termios_t;
        tcgetattr(STDIN_FILENO, &termios_t);
        termios_t.c_lflags &= ~ECHOCTL;
        tcsetattr(STDIN_FILENO, TCSANOW, &termios_t);
    

    Fork        #include <unistd.h>
        Assinatura: pid_t fork(void);
        Retorno da função
            Retorno do processo pai: fork() retorna o PID (Process ID) do processo filho.
            Retorno do processo filho: fork() retorna 0 no processo filho.
            Erro: Se ocorrer um erro ao tentar criar o processo, fork() retorna -1 e define o valor da variável global errno para indicar o erro.
        Comportamento do fork()
            Copia o espaço de memória: O processo filho recebe uma cópia do espaço de memória do processo pai. Inicialmente, isso inclui todas as variáveis, pilha e heap. No entanto, o sistema usa uma técnica chamada copy-on-write (COW), onde a cópia real da memória só é feita se um dos processos (pai ou filho) tentar modificar a memória.
            Execução paralela: Após a chamada para fork(), ambos os processos (pai e filho) continuam a ser executados. Não há garantias sobre a ordem em que eles serão executados, pois o escalonador do sistema operacional decide isso.
            Process IDs diferentes: O processo filho tem um PID diferente do pai. O pai pode obter o PID do filho a partir do valor retornado por fork(), enquanto o filho pode obter o PID do pai usando getppid().

    pid_t #include <sys/types.h>
        é um tipo de dado definido em <sys/types.h> que representa o Process ID (PID), que é um identificador único atribuído a cada processo em execução no sistema.
        Este tipo é usado principalmente em chamadas de sistema que lidam com processos, como fork(), wait(), getpid(), e getppid().

    wait()  #include <sys/wait.h>
    Assinatura: pid_t wait(int *status);
        A função wait() é usada pelo processo pai para esperar que um ou mais processos filhos terminem a execução.
        Parâmetros:
            status: Um ponteiro para um inteiro onde o estado de saída do processo filho pode ser armazenado. Esse valor pode ser analisado para determinar como o processo filho terminou (normalmente, se ele terminou com sucesso ou se terminou devido a um sinal).
                Se nao nos interessar o resultado do retorno podemos passar NULL
            Retorno:
                Retorna o PID do processo filho que terminou, ou -1 se ocorrer um erro (por exemplo, se não houver filhos para esperar).
        Devemos usar wait() sempre que usamos fork para aguardar pela terminacao dos processos filhos no parent para nao crirar processos zumbis ou orfaos


    waitpid()  <sys/wait.h>
    Assinatura: pid_t waitpid(pid_t pid, int *status, int options);
        Parâmetros
            pid: Especifica qual processo filho esperar. Existem alguns valores especiais que você pode usar:
                pid > 0: Espera pelo processo filho cujo PID é exatamente igual a pid.
                pid == 0: Espera por qualquer processo filho que esteja no mesmo grupo de processos que o chamador.
                pid < -1: Espera por qualquer processo filho cujo grupo de processos seja igual a -pid.
                pid == -1: Comportamento padrão de wait(), ou seja, espera por qualquer processo filho.
            status: Um ponteiro para um inteiro onde o status de término do processo será armazenado. O valor pode ser verificado usando macros como:
                WIFEXITED(status): Retorna true se o processo filho terminou normalmente (via exit ou _exit).
                WEXITSTATUS(status): Retorna o código de saída do filho se WIFEXITED for verdadeiro.
                WIFSIGNALED(status): Retorna true se o filho foi encerrado por um sinal.
                WTERMSIG(status): Retorna o número do sinal que encerrou o filho, se WIFSIGNALED for verdadeiro.
                WIFSTOPPED(status): Retorna true se o processo filho foi interrompido por um sinal (SIGSTOP ou similar).
                WSTOPSIG(status): Retorna o número do sinal que parou o processo, se WIFSTOPPED for verdadeiro.
            options: Permite especificar opções adicionais. Algumas opções comuns são:
                WNOHANG: Faz com que waitpid() não bloqueie se nenhum filho tiver terminado ainda. Se nenhum processo filho terminou, a função retorna imediatamente com 0.
                WUNTRACED: Faz com que waitpid() retorne se um processo filho foi parado, mas não terminado (por exemplo, após um sinal SIGSTOP).
                WCONTINUED: Faz com que waitpid() retorne se um processo filho que estava parado foi reiniciado (após um SIGCONT).

        Retorno
            Retorna o PID do processo filho que mudou de estado (terminou, foi interrompido, ou continuou).
            Retorna 0 se a opção WNOHANG foi usada e nenhum processo filho mudou de estado.
            Retorna -1 se ocorrer um erro (por exemplo, se o processo filho não existir ou não houver processos filhos). A variável global errno é configurada para indicar o erro.

     wait3, wait4 sao funcoes parecidas com a wait e waitpid mas que permitem recolher mais dados dos processos filhos terminados atraves de uma estrutura (struct rusage) // not necessary for minishell id say

    Processos Zumbis
        Um processo zumbi é um processo que já foi terminado, mas ainda tem uma entrada na tabela de processos. Isso ocorre porque o processo pai ainda não chamou wait() para recuperar o estado de saída do filho.
        Os processos zumbis estão em um estado de "terminado" (exited), mas ainda ocupam uma entrada na tabela de processos do sistema, pois o sistema precisa manter informações sobre o processo terminado até que o pai as recupere.
        Um processo se torna zumbi quando o processo filho termina sua execução ou se o processo pai não chama wait() para obter o status de saída do filho.
        O processo zumbi é removido da tabela de processos quando o pai chama wait() e recupera o status de saída do filho.

    Processos Órfãos
        Um processo órfão é um processo cujo processo pai terminou antes dele. Em outras palavras, o processo órfão ainda está em execução, mas não tem um pai vivo.
        Os processos órfãos são processos que estão em execução, mas não têm um pai ativo. Quando um processo pai termina, o sistema operacional adota automaticamente seus filhos, tornando-os órfãos.
        Um processo se torna órfão quando o processo pai termina sua execução ou um ou mais de seus filhos continuam a ser executados.
        O sistema operacional adota processos órfãos, geralmente atribuindo o processo init (PID 1) como seu novo pai. O processo init é responsável por gerenciar todos os processos órfãos e garantir que eles sejam limpos adequadamente.

    Se muitos processos zumbis acumularem, podem levar ao esgotamento da tabela de processos, impedindo que novos processos sejam criados
    O gerenciamento automático de processos órfãos pelo sistema operacional evita que esses processos fiquem perdidos e sem controle, garantindo que continuem a ser monitorados e finalizados adequadamente.

    
    access() #include <unistd.h>
        A função access() é usada em C para verificar os permissões de acesso a arquivos ou diretórios. Ela permite que o programa teste se um arquivo ou diretório pode ser lido, gravado ou executado, sem tentar abrir o arquivo diretamente.
        Assinatura: int access(const char *pathname, int mode);
        Parâmetros:
            pathname: O caminho do arquivo ou diretório que você deseja testar.
            mode: Especifica o tipo de verificação de permissão que você deseja realizar. Esse parâmetro pode ser uma combinação de vários valores (com operadores lógicos OR), entre eles:
                F_OK: Verifica se o arquivo ou diretório existe.
                R_OK: Verifica se o arquivo pode ser lido.
                W_OK: Verifica se o arquivo pode ser gravado.
                X_OK: Verifica se o arquivo pode ser executado (aplicável a arquivos executáveis).
        Retorno:
            0: Se o arquivo ou diretório tem as permissões solicitadas.
            -1: Se o arquivo ou diretório não tem as permissões solicitadas, ou se ocorreu um erro. Nesse caso, errno é configurado para indicar o erro específico.

        Podemos usar diretamente o modo X_OK ja que ele verifica tambem o mesmo que F_OK


    Variáveis de ambiente
        As variáveis de ambiente são pares chave-valor que armazenam informações sobre o ambiente do sistema, como o diretório atual, o shell, o caminho de busca de comandos (PATH), entre outras configurações do sistema. Elas são usadas por programas para obter informações sobre o ambiente em que estão sendo executados.
        São acessíveis para todos os processos e são herdadas por processos filhos. Por exemplo, um programa pode verificar a variável HOME para saber o diretório home do usuário ou PATH para localizar executáveis.
        Em C, você pode manipular variáveis de ambiente através de várias funções e também acessá-las diretamente no vetor envp[], passado para a função main().

    getenv() #include <stdlib.h> // vais ter de recriar uma get e setenv porque o setenv nao e allowed
        A função getenv() é usada para recuperar o valor de uma variável de ambiente.
        Assinatura: char *getenv(const char *name);
        Parametros
            name: O nome da variável de ambiente que você deseja obter.
        Retorno:
            Retorna um ponteiro para o valor da variável de ambiente correspondente ou NULL se a variável não estiver definida.

    envp[]
        O vetor envp[] (environment pointer) contém todas as variáveis de ambiente disponíveis no momento da execução do programa. Ele pode ser passado como o terceiro argumento da função main(). Se envp[] for passado, você pode iterar sobre ele para acessar todas as variáveis de ambiente.
        int main(int argc, char *argv[], char *envp[]);
        Podemos iterar pelos key=values com um loop normal e o formato e sempre KEY=value
        PS: vais ter de copiar o envp para poder adicionar com um custom export que pede e para ler vais ter de criar um custom getenv ja que estamos agora a armazenar envp dinamicamente num array dinamico

    File descriptors
    Descritores de arquivo (FDs) são inteiros não negativos que representam aberturas de arquivos ou recursos manipuláveis em sistemas Unix/Linux. Eles permitem acesso uniforme a arquivos, sockets e pipes, e são obtidos através de chamadas de sistema como open(). Cada descritor deve ser fechado com close() após o uso para liberar os recursos associados.
    0: stdin (entrada padrão).
    1: stdout (saída padrão).
    2: stderr (saída de erro padrão).
    3: file.txt (aberta pelo open pe)

    open() #include <fcntl.h>
        A função open() é usada para abrir um arquivo e retornar um descritor de arquivo
        Assinatura: int open(const char *pathname, int flags, mode_t mode);
        Parâmetros:
            pathname: O caminho do arquivo a ser aberto.
            flags: Um conjunto de opções que determina o modo como o arquivo será aberto. Alguns dos flags comuns incluem:
                O_RDONLY: Abre o arquivo apenas para leitura.
                O_WRONLY: Abre o arquivo apenas para escrita.
                O_RDWR: Abre o arquivo para leitura e escrita.
                O_CREAT: Cria o arquivo se ele não existir (normalmente usado em conjunto com O_WRONLY ou O_RDWR).
                O_TRUNC: Se o arquivo já existir e estiver sendo aberto para escrita, seu conteúdo será truncado a zero.
                O_APPEND: Escreve dados no final do arquivo.
            mode: Usado apenas se O_CREAT for especificado. Define as permissões do arquivo (ex: S_IRUSR | S_IWUSR, que dá permissão de leitura e escrita ao proprietário).
        Retorno:
            Retorna um descritor de arquivo (um inteiro) se a operação for bem-sucedida.
            Retorna -1 em caso de erro, e errno é configurado para indicar o erro.

    close() #include <unistd.h>
        A função close() é usada para fechar um descritor de arquivo que foi aberto anteriormente com open(). Isso libera os recursos associados ao descritor de arquivo.    
        Assinatura: int close(int fd)
        Parametros:
            fd: O descritor de arquivo a ser fechado.
        Retorno:
            Retorna 0 se a operação for bem-sucedida.
            Retorna -1 em caso de erro, e errno é configurado para indicar o erro.
    
    Exemplo de uso: int fd = open(./teste.txt, W_RDONLY); // o terceiro parametro so precisa de ser usado no caso de usarmos a flag O_CREATE
                    if (fd < 0)
                        error_handle();
                    ...
                    if (close(fd) < 0)
                        error_handle();
    
    execve() #include <unistd.h>
        Assinatura: int execve(const char *filename, char *const argv[], char *const envp[]);
        A função execve() é uma das chamadas de sistema em C usadas para executar um novo programa, substituindo o processo atual pelo novo programa especificado. É uma das várias funções exec disponíveis, e é considerada a forma mais básica e poderosa, pois permite passar os argumentos e variáveis de ambiente diretamente.
        Parametros:
            filename: O caminho para o arquivo executável que você deseja executar. Este arquivo deve ter permissões executáveis.
            argv: Um vetor de strings que contém os argumentos passados para o programa. O primeiro argumento (argv[0]) deve ser o nome do programa, seguido pelos argumentos reais. O vetor deve ser terminado por um ponteiro nulo (NULL)
            envp: Um vetor de strings que contém as variáveis de ambiente a serem passadas para o novo programa. Assim como argv, deve ser terminado por um ponteiro nulo (NULL).
        Em caso de sucesso, execve() não retorna; o processo atual é substituído pelo novo programa.
        Se ocorrer um erro, retorna -1 e errno é configurado para indicar o tipo de erro.

        Exemplo de uso:
            #include <stdio.h>
            #include <unistd.h>

            int main() 
            {
                // Argumentos para o comando
                char *argv[] = { "ls", "-l", NULL };  
                char *envp[] = { NULL };
                // Executa o comando 'ls -l'
                if (execve("/bin/ls", argv, envp) == -1) // se nao quiser mandar envp meto NULL
                    return 1;
                return 0;  // Este ponto nunca será alcançado se execve for bem-sucedido
            }
    